var documenterSearchIndex = {"docs":
[{"location":"resources/#Resources","page":"Resources","title":"Resources","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"Stochastic Variational Approach to Quantum-Mechanical Few-Body Problems, Yasuyuki Suzuki , Kálmán Varga\nThreshold photoproduction of neutral pions off protons in nuclear model with explicit mesons\nCorrelated Gaussians and low-discrepancy sequences\nQuasi-One-Dimensional Few-Body Systems with Correlated Gaussians\nCorrelated Gaussian method in Quantum Mechanics","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#Basis-expansion-of-the-Schrödinger-equation","page":"Theory","title":"Basis expansion of the Schrödinger equation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We are going to solve the Schrödinger equation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatHpsirangle = epsilonpsirangle","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where hatH is the Hamiltonian of a quantum few-body system, psirangle and epsilon are the eigenfunction and the eigenvalue to be found.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We shall expand the wave-function psirangle in terms of a set of basis functions irangle for i = 1 ldots n,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"psirangle = sum_i=1^n c_i irangle","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Inserting the expansion into the Schrödinger equation and multiplying from the left with langle k for 1 leq k leq n gives","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"sum_i=1^n langle khatHirangle c_i = epsilon sum_i=1^n langle kirangle c_i","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Or, in the matrix notation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Hc = epsilon Nc","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where H and N are correspondingly the Hamiltonian and the overlap matrices with the matrix elements","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"H_ki = langle khatHirangle quad N_ki = langle kirangle","category":"page"},{"location":"theory/#Gaussians-as-basis-functions","page":"Theory","title":"Gaussians as basis functions","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We shall use the so-called Correlated Gaussians (or Explicitly Correlated Gaussians) as the basis functions. For a system of N particles with coordinates vecr_i, i = 1 ldots N, the Correlated Gaussian is defined as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g(vecr_1 ldots vecr_N) = exp left( - sum_ij=1^N A_ijvecr_i cdot vecr_j - sum_i=1^N vecs_i cdot vecr_i right)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where vecr_i cdot vecr_j denotes the dot-product of the two vectors; and where A, a symmetric positive-defined matrix, and vecs_i, i=1ldotsN, the shift-vectors, are (cleverly chosen) parameters of the Gaussian.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In matrix notation,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g(vecr) = exp left( -vecr^T A vecr + vecs^T vecr right)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where vecr is the column of the coordinates vecr_i and vecs is the column of the shift-vectors vecs_i,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"vecr =\nbeginpmatrix\nvecr_1 \nvdots \nvecr_N\nendpmatrix quad\nvecs =\nbeginpmatrix\nvecs_1 \nvdots \nvecs_N\nendpmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"vecr^T A vecr + vecs^T vecr = sum_ij vecr_i cdot A_ijvecr_j + sum_i vecs_i cdot vecr_i","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Suppose you want to calculate the ground state energy of the hydrogen anion in the rest-frame of the proton. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using FewBodyECG\nusing LinearAlgebra\nusing Plots\nusing QuasiMonteCarlo\n\nmasses = [1.0e15, 1.0, 1.0]\npsys = ParticleSystem(masses)\n\nK = Diagonal([0.0, 1 / 2, 1 / 2])\nK_transformed = psys.J * K * psys.J'\n\nw_list = [[1, -1, 0], [1, 0, -1], [0, 1, -1]]\n\nw_raw = [psys.U' * w for w in w_list]\n\nlet\n    n_basis = 50\n    b1 = default_b0(psys.scale)\n    method = :quasirandom\n    basis_fns = GaussianBase[]\n    E₀_list = Float64[]\n    coeffs = [-1.0, -1.0, +1.0]\n\n    for i in 1:n_basis\n        bij = generate_bij(method, i, length(w_raw), b1; qmc_sampler = SobolSample())\n        A = _generate_A_matrix(bij, w_raw)\n        push!(basis_fns, Rank0Gaussian(A))\n\n        basis = BasisSet(basis_fns)\n        ops = Operator[\n            KineticOperator(K_transformed);\n            (CoulombOperator(c, w) for (c, w) in zip(coeffs, w_raw))...\n        ]\n\n        H = build_hamiltonian_matrix(basis, ops)\n        S = build_overlap_matrix(basis)\n        vals, _ = solve_generalized_eigenproblem(H, S)\n        E₀_step = minimum(vals)\n\n        push!(E₀_list, E₀_step)\n        println(\"Step $i: E₀ = $E₀_step\")\n\n    end\n\n    E₀ = minimum(E₀_list)\n    Eᵗʰ = -0.527751016523\n    ΔE = abs(E₀ - Eᵗʰ)\n    @show ΔE\n\n    plot(\n        1:n_basis, E₀_list, xlabel = \"Number of Gaussians\", ylabel = \"E₀ [Hartree]\",\n        lw = 2, label = \"Ground state energy\", title = \"Hydrogen Anion Convergence\"\n    )\n\nend","category":"page"},{"location":"#FewBodyECG.jl","page":"Home","title":"FewBodyECG.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: WIP\nThis is work in progress. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Get the latest stable release with Julia's package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia ] add FewBodyECG","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We consider a system of a positron and two electrons. The energy of this system has been very accurately calculated by various approaches and it has been found to be -0.262005 in atomic units (a.u.). We calculate the ground-state energy of this systems using correlated Gaussian bases constructed stochastically with pseudorandom and quasirandom sequences. The Hamiltonian of the system is given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"H = - sum_i=1^3 frac12m_ifracpartial^2partial boldsymbolr_i^2 + sum_ij=1^3 fracq_i q_jboldsymbolr_i-boldsymbolr_j","category":"page"},{"location":"","page":"Home","title":"Home","text":"The masses of the three constituents are m_i = {1, 1, 1} and the charges q_i = {+1, −1, −1}. We can estimate the ground state of this Coulombic three-body system using 50 Gaussians","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FewBodyECG\nusing LinearAlgebra\nusing Plots\nusing QuasiMonteCarlo\n\nmasses = [1.0, 1.0, 1.0]\npsys = ParticleSystem(masses)\n\nK = Diagonal([1 / 2, 1 / 2, 1 / 2])\nK_transformed = psys.J * K * psys.J'\n\nw_list = [[1, -1, 0], [1, 0, -1], [0, 1, -1]]\nw_raw = [psys.U' * w for w in w_list]\n\ncoeffs = [+1.0, -1.0, -1.0]\n\nlet\n    n_basis = 100\n    b1 = default_b0(psys.scale)\n    method = :quasirandom\n    basis_fns = GaussianBase[]\n    E₀_list = Float64[]\n\n    for i in 1:n_basis\n        bij = generate_bij(method, i, length(w_raw), b1; qmc_sampler = SobolSample())\n        A = _generate_A_matrix(bij, w_raw)\n        push!(basis_fns, Rank0Gaussian(A))\n\n        basis = BasisSet(basis_fns)\n        ops = Operator[\n            KineticOperator(K_transformed);\n            (CoulombOperator(c, w) for (c, w) in zip(coeffs, w_raw))...\n        ]\n\n        H = build_hamiltonian_matrix(basis, ops)\n        S = build_overlap_matrix(basis)\n        vals, vecs = solve_generalized_eigenproblem(H, S)\n        global c₀ = vecs[:, 1]\n        E₀ = minimum(vals)\n\n        push!(E₀_list, E₀)\n        println(\"Step $i: E₀ = $E₀\")\n    end\n\n    E₀ = minimum(E₀_list)\n    Eᵗʰ = -0.2620050702328\n    ΔE = abs(E₀ - Eᵗʰ)\n    @show ΔE\n\n    r = range(0.01, 14.0, length = 400)\n    ρ_r = [rval^2 * abs2(ψ₀([rval, 0.0], c₀, basis_fns)) for rval in r]\n\n    p1 = plot(\n        r, ρ_r, xlabel = \"r (a.u.)\", ylabel = \"r²|ψ₀(r)|²\",\n        lw = 2, label = \"r²C(r)\", title = \"Electron-Positron Correlation Function\"\n    )\n\n\n    p2 = plot(\n        1:n_basis, E₀_list, xlabel = \"Number of Gaussians\", ylabel = \"E₀ [Hartree]\",\n        lw = 2, label = \"Ground state energy\", title = \"Positronium Convergence\"\n    )\n\n    plot(p1, p2, layout = (2, 1))\n\nend","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"}]
}
