var documenterSearchIndex = {"docs":
[{"location":"resources/#Resources","page":"Resources","title":"Resources","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"Stochastic Variational Approach to Quantum-Mechanical Few-Body Problems, Yasuyuki Suzuki , Kálmán Varga\nThreshold photoproduction of neutral pions off protons in nuclear model with explicit mesons\nCorrelated Gaussians and low-discrepancy sequences\nQuasi-One-Dimensional Few-Body Systems with Correlated Gaussians\nCorrelated Gaussian method in Quantum Mechanics","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#Basis-expansion-of-the-Schrödinger-equation","page":"Theory","title":"Basis expansion of the Schrödinger equation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We are going to solve the Schrödinger equation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatHpsirangle = epsilonpsirangle","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where hatH is the Hamiltonian of a quantum few-body system, psirangle and epsilon are the eigenfunction and the eigenvalue to be found.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We shall expand the wave-function psirangle in terms of a set of basis functions irangle for i = 1 ldots n,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"psirangle = sum_i=1^n c_i irangle","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Inserting the expansion into the Schrödinger equation and multiplying from the left with langle k for 1 leq k leq n gives","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"sum_i=1^n langle khatHirangle c_i = epsilon sum_i=1^n langle kirangle c_i","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Or, in the matrix notation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Hc = epsilon Nc","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where H and N are correspondingly the Hamiltonian and the overlap matrices with the matrix elements","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"H_ki = langle khatHirangle quad N_ki = langle kirangle","category":"page"},{"location":"theory/#Gaussians-as-basis-functions","page":"Theory","title":"Gaussians as basis functions","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We shall use the so-called Correlated Gaussians (or Explicitly Correlated Gaussians) as the basis functions. For a system of N particles with coordinates vecr_i, i = 1 ldots N, the Correlated Gaussian is defined as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g(vecr_1 ldots vecr_N) = exp left( - sum_ij=1^N A_ijvecr_i cdot vecr_j - sum_i=1^N vecs_i cdot vecr_i right)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where vecr_i cdot vecr_j denotes the dot-product of the two vectors; and where A, a symmetric positive-defined matrix, and vecs_i, i=1ldotsN, the shift-vectors, are (cleverly chosen) parameters of the Gaussian.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In matrix notation,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g(vecr) = exp left( -vecr^T A vecr + vecs^T vecr right)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where vecr is the column of the coordinates vecr_i and vecs is the column of the shift-vectors vecs_i,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"vecr =\nbeginpmatrix\nvecr_1 \nvdots \nvecr_N\nendpmatrix quad\nvecs =\nbeginpmatrix\nvecs_1 \nvdots \nvecs_N\nendpmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"vecr^T A vecr + vecs^T vecr = sum_ij vecr_i cdot A_ijvecr_j + sum_i vecs_i cdot vecr_i","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Suppose you want to calculate the ground state energy of the hydrogen anion in the rest-frame of the proton. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using FewBodyPhysics\nusing LinearAlgebra\nusing Plots\n\nmasses = [1e15, 1.0, 1.0] \npsys = ParticleSystem(masses)\n\nK = Diagonal([0.0, 1/2, 1/2])\nK_transformed = psys.J * K * psys.J'\n\nw_list = [ [1, -1, 0], [1, 0, -1], [0, 1, -1] ]\n\nw_raw = [psys.U' * w for w in w_list]\n\nlet\n    n_basis = 50\n    b1 = default_b0(psys.scale)\n    method = :quasirandom  \n    basis_fns = GaussianBase[]\n    E₀_list = Float64[]\n    coeffs = [-1.0, -1.0, +1.0]\n\n    for i in 1:n_basis\n        bij = generate_bij(method, i, length(w_raw), b1)\n        A = generate_A_matrix(bij, w_raw)\n        push!(basis_fns, Rank0Gaussian(A))\n\n        basis = BasisSet(basis_fns)\n        ops = Operator[\n            KineticEnergy(K_transformed);\n            (CoulombPotential(c, w) for (c, w) in zip(coeffs, w_raw))...\n        ]\n                \n        H = build_hamiltonian_matrix(basis, ops)\n        S = build_overlap_matrix(basis)\n        vals, _ = solve_generalized_eigenproblem(H, S)\n        E₀_step = minimum(vals)\n\n        push!(E₀_list, E₀_step)\n        println(\"Step $i: E₀ = $E₀_step\")\n\n    end\n\n    E₀ = minimum(E₀_list)\n    Eᵗʰ = -0.527751016523\n    ΔE = abs(E₀ - Eᵗʰ)\n    @show ΔE\n\n    plot(1:n_basis, E₀_list, xlabel=\"Number of Gaussians\", ylabel=\"E₀ [Hartree]\",\n         lw=2, label=\"Ground state energy\", title=\"Hydrogen Anion Convergence\")\n\nend","category":"page"},{"location":"#FewBodyPhysics.jl","page":"FewBodyPhysics.jl","title":"FewBodyPhysics.jl","text":"","category":"section"},{"location":"","page":"FewBodyPhysics.jl","title":"FewBodyPhysics.jl","text":"warning: WIP\nThis is work in progress. ","category":"page"},{"location":"#Installation","page":"FewBodyPhysics.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"FewBodyPhysics.jl","title":"FewBodyPhysics.jl","text":"Get the latest stable release with Julia's package manager:","category":"page"},{"location":"","page":"FewBodyPhysics.jl","title":"FewBodyPhysics.jl","text":"julia ] add FewBodyPhysics","category":"page"},{"location":"#Example","page":"FewBodyPhysics.jl","title":"Example","text":"","category":"section"},{"location":"","page":"FewBodyPhysics.jl","title":"FewBodyPhysics.jl","text":"We consider a system of a positron and two electrons. The energy of this system has been very accurately calculated by various approaches and it has been found to be -0.262005 in atomic units (a.u.). We calculate the ground-state energy of this systems using correlated Gaussian bases constructed stochastically with pseudorandom and quasirandom sequences. The Hamiltonian of the system is given by","category":"page"},{"location":"","page":"FewBodyPhysics.jl","title":"FewBodyPhysics.jl","text":"H = - sum_i=1^3 frac12m_ifracpartial^2partial boldsymbolr_i^2 + sum_ij=1^3 fracq_i q_jboldsymbolr_i-boldsymbolr_j","category":"page"},{"location":"","page":"FewBodyPhysics.jl","title":"FewBodyPhysics.jl","text":"The masses of the three constituents are m_i = {1, 1, 1} and the charges q_i = {+1, −1, −1}. We can estimate the ground state of this Coulombic three-body system using 50 Gaussians","category":"page"},{"location":"","page":"FewBodyPhysics.jl","title":"FewBodyPhysics.jl","text":"using FewBodyPhysics\nusing LinearAlgebra\nusing Plots\n\nmasses = [1.0, 1.0, 1.0]\npsys = ParticleSystem(masses)\n\nK = Diagonal([1/2, 1/2, 1/2])\nK_transformed = psys.J * K * psys.J'\n\nw_list = [[1, -1, 0], [1, 0, -1], [0, 1, -1]]\nw_raw = [psys.U' * w for w in w_list]\n\ncoeffs = [+1.0, -1.0, -1.0]\n\nlet\n    n_basis = 50\n    b1 = default_b0(psys.scale)\n    method = :psudorandom\n    basis_fns = GaussianBase[]\n    E₀_list = Float64[]\n\n    for i in 1:n_basis\n        bij = generate_bij(method, i, length(w_raw), b1)\n        A = generate_A_matrix(bij, w_raw)\n        push!(basis_fns, Rank0Gaussian(A))\n\n        basis = BasisSet(basis_fns)\n        ops = Operator[\n            KineticEnergy(K_transformed);\n            (CoulombPotential(c, w) for (c, w) in zip(coeffs, w_raw))...\n        ]\n\n        H = build_hamiltonian_matrix(basis, ops)\n        S = build_overlap_matrix(basis)\n        vals, vecs = solve_generalized_eigenproblem(H, S)\n        global c₀ = vecs[:, 1]\n        E₀ = minimum(vals)\n\n        push!(E₀_list, E₀)\n        println(\"Step $i: E₀ = $E₀\")\n    end\n\n    E₀ = minimum(E₀_list)\n    Eᵗʰ = -0.2620050702328\n    ΔE = abs(E₀ - Eᵗʰ)\n    @show ΔE\n\n    #  function\n    r = range(0.01, 14.0, length=400)\n    ρ_r = [rval^2 * abs2(ψ₀([rval, 0.0], c₀, basis_fns)) for rval in r]\n    \n    p1 = plot(r, ρ_r, xlabel=\"r (a.u.)\", ylabel=\"r²|ψ₀(r)|²\",\n              lw=2, label=\"r²C(r)\", title=\"Electron-Positron Correlation Function\")\n    \n\n    # Energy convergence\n    p2 = plot(1:n_basis, E₀_list, xlabel=\"Number of Gaussians\", ylabel=\"E₀ [Hartree]\",\n    lw=2, label=\"Ground state energy\", title=\"Positronium Convergence\")\n\n    plot(p1, p2, layout=(2, 1))\n\nend","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#FewBodyPhysics.Utils.plot_density-Tuple{Any, Any}","page":"API","title":"FewBodyPhysics.Utils.plot_density","text":"plot_density(c₀, basis_fns; range=(-4.0, 4.0), N=200)\n\nPlots the 2D probability density |ψ₀(x, y)|² in Jacobi space.\n\n\n\n\n\n","category":"method"},{"location":"API/#FewBodyPhysics.Utils.plot_wavefunction-Tuple{Any, Any}","page":"API","title":"FewBodyPhysics.Utils.plot_wavefunction","text":"plot_wavefunction(c₀, basis_fns; axis=1, range=(-4.0, 4.0), N=400)\n\nPlots a 1D slice of the wavefunction ψ₀(x, 0) or ψ₀(0, y).\n\n\n\n\n\n","category":"method"},{"location":"API/#FewBodyPhysics.Utils.ψ₀-Tuple{Vector{Float64}, Vector{Float64}, Vector}","page":"API","title":"FewBodyPhysics.Utils.ψ₀","text":"ψ₀(r::Vector{Float64}, c₀::Vector{Float64}, basis_fns::Vector{<:GaussianBase})\n\nEvaluates the ground state wavefunction ψ₀ at position r.\n\n\n\n\n\n","category":"method"},{"location":"API/#FewBodyPhysics.Sampling.compute_ground_state_energy-Tuple{BasisSet, Vector{Operator}}","page":"API","title":"FewBodyPhysics.Sampling.compute_ground_state_energy","text":"computegroundstate_energy(basis::BasisSet, ops::Vector{Operator})\n\nConstruct the Hamiltonian and overlap matrices and return the lowest eigenvalue.\n\n\n\n\n\n","category":"method"},{"location":"API/#FewBodyPhysics.Sampling.corput","page":"API","title":"FewBodyPhysics.Sampling.corput","text":"corput(n::Int, b::Int=2)\n\nComputes the n-th number in the van der Corput sequence in base b using digit reversal. Follows the standard definition:     qₙ = ∑ dₖ(n) * b^(-k-1)\n\n\n\n\n\n","category":"function"},{"location":"API/#FewBodyPhysics.Sampling.generate_basis","page":"API","title":"FewBodyPhysics.Sampling.generate_basis","text":"generate_basis(widths::Vector{Matrix{Float64}}, rank::Int=0)\n\nConstruct a BasisSet from a list of correlation matrices and optional rank.\n\n\n\n\n\n","category":"function"},{"location":"API/#FewBodyPhysics.Sampling.generate_bij-Tuple{Symbol, Int64, Int64, Float64}","page":"API","title":"FewBodyPhysics.Sampling.generate_bij","text":"generate_bij(method::Symbol, i::Int, n_terms::Int, b1::Float64) -> Vector{Float64}\n\nGenerate a bij vector using the specified sampling method. Supported methods: :quasirandom, :psudorandom\n\n\n\n\n\n","category":"method"},{"location":"API/#FewBodyPhysics.Sampling.halton-Tuple{Int64, Int64}","page":"API","title":"FewBodyPhysics.Sampling.halton","text":"halton(n::Int, d::Int)\n\nGenerates the nth Halton sequence vector in d dimensions.\n\n\n\n\n\n","category":"method"},{"location":"API/#FewBodyPhysics.Coordinates.ParticleSystem","page":"API","title":"FewBodyPhysics.Coordinates.ParticleSystem","text":"struct ParticleSystem\n\nA structure representing a system of particles with associated masses and coordinate transformations.\n\nFields\n\nmasses::Vector{Float64}: A vector containing the masses of the particles in the system. Must contain at least two elements.\nJ::Matrix{Float64}: The Jacobi transformation matrix for the particle system, computed based on the masses.\nU::Matrix{Float64}: An auxiliary transformation matrix for the particle system, computed based on the masses.\nscale::Union{Symbol,Nothing}: An optional symbol indicating the scale of the system (e.g., :atomic, :molecular, :nuclear). Defaults to nothing.\n\nConstructor\n\nParticleSystem(masses::Vector{Float64}; scale::Union{Symbol,Nothing}=nothing):  Creates a new ParticleSystem instance. The masses vector must contain at least two elements. The scale parameter is optional and can be used to specify the scale of the system. The Jacobi and auxiliary transformation matrices (J and U) are computed internally using the jacobi_transform function.\n\n\n\n\n\n","category":"type"},{"location":"API/#FewBodyPhysics.Coordinates.default_b0-Tuple{Union{Nothing, Symbol}}","page":"API","title":"FewBodyPhysics.Coordinates.default_b0","text":"default_b0(scale::Union{Symbol,Nothing}) -> Float64\n\nReturns a default value for the parameter b0 based on the provided scale.\n\nArguments\n\nscale::Union{Symbol,Nothing}: A symbol representing the scale type or nothing.\n:atomic: Returns 1.0, corresponding to the Bohr radius in atomic units.\n:molecular: Returns 3.0, representing a typical molecular bond length.\n:nuclear: Returns 0.03, approximately 1 femtometer in atomic units.\nnothing: Returns 1.0 as a fallback default.\n\n\n\n\n\n","category":"method"},{"location":"API/#FewBodyPhysics.Coordinates.jacobi_transform-Tuple{Vector{Float64}}","page":"API","title":"FewBodyPhysics.Coordinates.jacobi_transform","text":"jacobi_transform(masses::Vector{Float64})::Tuple{Matrix{Float64}, Matrix{Float64}}\n\nComputes the Jacobi transformation matrix J and its pseudoinverse U for a given vector of masses.\n\nArguments\n\nmasses::Vector{Float64}: A vector of masses for the system. Must contain at least two masses.\n\nReturns\n\nTuple{Matrix{Float64}, Matrix{Float64}}: A tuple containing:\nJ::Matrix{Float64}: The Jacobi transformation matrix.\nU::Matrix{Float64}: The pseudoinverse of the Jacobi transformation matrix.\n\nDetails\n\nThe Jacobi transformation is used to convert the coordinates of a system of particles into a set of relative coordinates. The transformation matrix J is constructed based on the masses of the particles, and its pseudoinverse U is computed using the pinv function.\n\nConstraints\n\nThe input vector masses must have a length of at least 2. An assertion is raised if this condition is not met.\n\n\n\n\n\n","category":"method"},{"location":"API/#FewBodyPhysics.Coordinates.shift_vectors","page":"API","title":"FewBodyPhysics.Coordinates.shift_vectors","text":"shift_vectors(a::Matrix{Float64}, b::Matrix{Float64}, mat::Union{Nothing, Matrix{Float64}}=nothing) -> Float64\n\nCompute a weighted sum of dot products between columns of two matrices a and b,  optionally using a weighting matrix mat.\n\nArguments\n\na::Matrix{Float64}: A matrix where each column represents a vector.\nb::Matrix{Float64}: A matrix where each column represents a vector. Must have the same number of columns as a.\nmat::Union{Nothing, Matrix{Float64}}: An optional square weighting matrix. If nothing is provided, the identity matrix is used.\n\nReturns\n\nFloat64: The computed weighted sum of dot products.\n\nConstraints\n\nThe number of columns in a and b must be the same.\nIf mat is provided, it must be a square matrix with dimensions equal to the number of columns in a and b.\n\n\n\n\n\n","category":"function"},{"location":"API/#FewBodyPhysics.Coordinates.transform_list-Tuple{Vector{Float64}}","page":"API","title":"FewBodyPhysics.Coordinates.transform_list","text":"transform_list(α::Vector{Float64})::Vector{Matrix{Float64}}\n\nTransforms a vector of Float64 values into a vector of Matrix{Float64} objects.  Each element of the input vector α is wrapped into a 1x1 matrix and returned as  an element of the resulting vector.\n\nArguments\n\nα::Vector{Float64}: A vector of Float64 values to be transformed.\n\nReturns\n\nVector{Matrix{Float64}}: A vector where each element is a 1x1 matrix containing  the corresponding value from the input vector α.\n\n\n\n\n\n","category":"method"},{"location":"API/#FewBodyPhysics.Optimization.optimize_ground_state_energy-Tuple{Vector{Matrix{Float64}}, Vector{Operator}}","page":"API","title":"FewBodyPhysics.Optimization.optimize_ground_state_energy","text":"optimizegroundstateenergy(initwidths::Vector{Matrix{Float64}}, ops::Vector{Operator}; max_iter=100)\n\nUses local optimization (Nelder-Mead) on Gaussian widths to minimize ground state energy.\n\n\n\n\n\n","category":"method"}]
}
